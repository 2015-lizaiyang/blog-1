# [译] [PJA] [504] AMD 规范

> * Original: [AMD - Chapter 5. Modules - Programming JavaScript Applications](http://chimera.labs.oreilly.com/books/1234000000262/ch05.html#amd)
> * Translated by: [cssmagic](https://github.com/cssmagic)

## AMD

On the client side, there is often a need to load modules asynchronously at runtime in order to avoid the need for the client to download the entire codebase every time the app is loaded. Imagine you have an app like twitter, where users can post messages or status updates. The core of the application is the messaging feature. However, you also have a large profile editing module that allows users to customize the look of their profile pages.

Users will generally update the look of their profiles a few times per year, so the entire profile editing module (all 50,000 lines of it) goes completely unused 99% of the time. What you need is a way to defer the loading of the profile editor until the user actually enters edit mode. You could just make it a separate page, but then the user has to endure a page refresh, when maybe all they wanted to do was change their profile image. It would be a much better experience to keep this all on one page, with no new page load.

The module pattern doesn't solve this problem. CommonJS modules (like those used by Node) are not asynchronous. In the future, JavaScript will have a native module system that works in the browser (see [“Harmony Modules”][11]), but it's very young technology that may not be widely implemented in all major browsers for the foreseeable future.

_Asynchronous Module Definition_ (AMD) is an interim solution to the problem. It works by wrapping the module inside a function called `define()`. The call signature looks like this:

    define([moduleId,] dependencies, definitionFunction);

The `moduleId` parameter is a string that will identify the module, however, this parameter has fallen out of favor because changes in the application or module structure can necessitate a refactor, and there really is no need for an ID in the first place. If you leave it out and begin your define call with the dependency list, you'll create a more adaptable _anonymous module_:

    define(['ch05/amd1', 'ch05/amd2'],
      function myModule(amd1, amd2) {
        var testResults = {
            test1: amd1.test(),
            test2: amd2.test()
          },

          // Define a public API for your module:
          api = {
            testResults: function () {
              return testResults;
            }
          };

        return api;
      });

To kick it off, call `require()`. You specify dependencies similar to `define()`:

    require(['ch05-amd'], function (amd) {
      var results = amd.testResults();

      test('AMD with Require.js', function () {
        equal(results.test1, true,
          'First dependency loaded correctly.');

        equal(results.test2, true,
          'Second dependency loaded correctly.');
      });
    });

Use anonymous modules wherever possible in order to avoid refactors.

The problem with this approach is that if you define your module this way, it can only be used with an AMD loader, such as Require.js or Curl.js (two popular AMD loaders). However, it is possible to get the best of both AMD and module pattern modules. Simply create your module as you normally would, at the end of the wrapping function, add this:

    if (typeof define === 'function') {
      define([], function () {
        return api;
      });
    }

That way, it will be possible to load your module asynchronously if you want to, but your module will still function properly if it's loaded with a simple script tag, or compiled together with a bunch of other modules. This is the pattern that jQuery uses to add AMD loader support. The only trouble with this pattern is that dependency timing is a little more complicated. You'll need to ensure that your dependencies have loaded before you try to use them.

### Plugins

Loader plugins are an AMD mechanism that allow you to load non-JavaScript resources, such as templates, css, etc... Require.js supplies a text! plugin that you can use to load your HTML templates. To use a plugin, simply prefix the file path with the plugin name:

    'use strict';
    require(['ch05/mymodule.js', 'text!ch05/mymodule.html'],
        function (myModule, view) {
      var container = document.body,
        css = 'ch05/mymodule.css';

      myModule.render(container, view, css);

      test('AMD Plugins', function () {
        equal($('http://chimera.labs.oreilly.com#mymodule').text(), 'Hello, world!',
          'Plugin loading works.');
      });
    });

Here's what `mymodule.js` looks like:

    define(function () {
      'use strict';
      var api = {
        render: function render(container, view, css) {
          loadCss('ch05/mymodule.css');

          $(view).text('Hello, world!')
            .appendTo(container);
        }
      };

      return api;
    });

And the `mymodule.html` template:

The stylesheet is simple:

    #mymodule {
      font-size:2em;
      color: green;
    }

Note that the css is not loaded as a plugin. Instead, the url is assigned to a variable and passed into the `.render()` method for manual loading. The `loadCSS()` function looks like this:

    function loadCss(url) {
      $('', {
        type: 'text/css',
        rel: 'stylesheet',
        href: url,
      }).appendTo('head');
    }

This obviously isn't an ideal solution, but as of this writing, there is no standard recommended css! plugin for Require.js. There is a css! plugin for Curl.js, and you might want to try Xstyle. Use them the same way you define the HTML template.

AMD has a couple of serious drawbacks. First, it requires you to include a boilerplate wrapper function for every module, and second, it forces you to either compile your whole application in a compile step, or asynchronously load every single module on the client side, which, in spite of advertising to the contrary, could actually slow down the load and execution of your scripts due to simultaneous download limits and connection latency.

I recommend the precompile solution over the asynchronous load solution, and as long as you're doing that anyway, you may as well be using the simplified CommonJS syntax and a tool like Browserify. More on that soon.

[11]: http://chimera.labs.oreilly.com/ch05.html#ch9phz70i00005ig1kqp3ed7t (Harmony Modules)

***

&copy; Creative Commons BY-NC-ND 3.0 &nbsp; | &nbsp; [我要订阅](http://www.cssmagic.net/blog/subscribe) &nbsp; | &nbsp; [我要捐助](http://www.cssmagic.net/blog/donate)

&nbsp;
> * [参与评论](https://github.com/cssmagic/blog/issues/XXXXXXXXXX)
> * [查看更多文章](https://github.com/cssmagic/blog/issues?state=open)
